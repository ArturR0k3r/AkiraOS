#include "display_ili9341.h"
#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/sys/util.h>
#include <zephyr/sys/__assert.h>
#include <stdlib.h>
LOG_MODULE_REGISTER(ili9341, LOG_LEVEL_DBG);

static const struct device *spi_dev_local;
static const struct device *gpio_dev_local;
static struct spi_config *spi_cfg_local;

static int ili9341_send_cmd(uint8_t cmd)
{
    struct spi_buf tx_buf = {.buf = &cmd, .len = 1};
    struct spi_buf_set tx_bufs = {.buffers = &tx_buf, .count = 1};
        // Manually control CS
        gpio_pin_set(gpio_dev_local, ILI9341_CS_PIN, 0); // CS low
        gpio_pin_set(gpio_dev_local, DC_GPIO_PIN, 0);
        k_sleep(K_USEC(1));
        int ret = spi_write(spi_dev_local, spi_cfg_local, &tx_bufs);
        k_sleep(K_USEC(1));
        gpio_pin_set(gpio_dev_local, ILI9341_CS_PIN, 1); // CS high
        LOG_DBG("SPI CMD: 0x%02X", cmd);
        if (ret < 0)
        {
            LOG_ERR("spi_write (cmd/data) failed: %d", ret);
        }
        return ret;
}

static int ili9341_send_data(uint8_t *data, size_t len)
{
    struct spi_buf tx_buf = {.buf = data, .len = len};
    struct spi_buf_set tx_bufs = {.buffers = &tx_buf, .count = 1};
        // Manually control CS
        gpio_pin_set(gpio_dev_local, ILI9341_CS_PIN, 0); // CS low
        gpio_pin_set(gpio_dev_local, DC_GPIO_PIN, 1);
        k_sleep(K_USEC(1));
        int ret = spi_write(spi_dev_local, spi_cfg_local, &tx_bufs);
        k_sleep(K_USEC(1));
        gpio_pin_set(gpio_dev_local, ILI9341_CS_PIN, 1); // CS high
        LOG_DBG("SPI DATA: len=%d", (int)len);
        if (ret < 0)
        {
            LOG_ERR("spi_write (cmd/data) failed: %d", ret);
        }
        return ret;
}

static int ili9341_send_data_byte(uint8_t data)
{
    return ili9341_send_data(&data, 1);
}

int ili9341_init(const struct device *spi_dev, const struct device *gpio_dev,
                 struct spi_config *spi_cfg)
{
    spi_dev_local = spi_dev;
    gpio_dev_local = gpio_dev;
    spi_cfg_local = spi_cfg;

    // Hardware reset
    gpio_pin_set(gpio_dev_local, RESET_GPIO_PIN, 0);
    k_sleep(K_MSEC(50)); // Increased delay
    gpio_pin_set(gpio_dev_local, RESET_GPIO_PIN, 1);
    k_sleep(K_MSEC(200)); // Increased delay

    // Software reset
    ili9341_send_cmd(ILI9341_SWRESET);
    k_sleep(K_MSEC(200)); // Increased delay

    // Exit sleep mode
    ili9341_send_cmd(ILI9341_SLPOUT);
    k_sleep(K_MSEC(200)); // Increased delay

    // Power control 1
    ili9341_send_cmd(ILI9341_PWCTR1);
    ili9341_send_data_byte(0x23);

    // Power control 2
    ili9341_send_cmd(ILI9341_PWCTR2);
    ili9341_send_data_byte(0x10);

    // VCOM control 1
    ili9341_send_cmd(ILI9341_VMCTR1);
    ili9341_send_data_byte(0x3E);
    ili9341_send_data_byte(0x28);

    // VCOM control 2
    ili9341_send_cmd(ILI9341_VMCTR2);
    ili9341_send_data_byte(0x86);

    // Memory access control
    ili9341_send_cmd(ILI9341_MADCTL);
    ili9341_send_data_byte(0x48);

    // Pixel format
    ili9341_send_cmd(ILI9341_COLMOD);
    ili9341_send_data_byte(0x55);

    // Positive gamma correction
    ili9341_send_cmd(ILI9341_GMCTRP1);
    uint8_t gamma_p[] = {0x0F, 0x31, 0x2B, 0x0C, 0x0E, 0x08, 0x4E, 0xF1,
                         0x37, 0x07, 0x10, 0x03, 0x0E, 0x09, 0x00};
    ili9341_send_data(gamma_p, sizeof(gamma_p));

    // Negative gamma correction
    ili9341_send_cmd(ILI9341_GMCTRN1);
    uint8_t gamma_n[] = {0x00, 0x0E, 0x14, 0x03, 0x11, 0x07, 0x31, 0xC1,
                         0x48, 0x08, 0x0F, 0x0C, 0x31, 0x36, 0x0F};
    ili9341_send_data(gamma_n, sizeof(gamma_n));

    // Display on
    ili9341_send_cmd(ILI9341_DISPON);
    k_sleep(K_MSEC(100));
    return 0;
}

static int ili9341_set_area(uint16_t x_start, uint16_t y_start, uint16_t x_end, uint16_t y_end)
{
    ili9341_send_cmd(ILI9341_CASET);
    ili9341_send_data_byte(x_start >> 8);
    ili9341_send_data_byte(x_start & 0xFF);
    ili9341_send_data_byte(x_end >> 8);
    ili9341_send_data_byte(x_end & 0xFF);

    ili9341_send_cmd(ILI9341_PASET);
    ili9341_send_data_byte(y_start >> 8);
    ili9341_send_data_byte(y_start & 0xFF);
    ili9341_send_data_byte(y_end >> 8);
    ili9341_send_data_byte(y_end & 0xFF);
    return 0;
}

int ili9341_fill_color(uint16_t color)
{
    ili9341_set_area(0, 0, ILI9341_DISPLAY_WIDTH - 1, ILI9341_DISPLAY_HEIGHT - 1);
    ili9341_send_cmd(ILI9341_RAMWR);

    uint8_t color_bytes[2] = {color >> 8, color & 0xFF};
    const size_t chunk_size = 1024;
    uint8_t *chunk_buffer = k_malloc(chunk_size * 2);
    if (!chunk_buffer)
        return -ENOMEM;
    for (size_t i = 0; i < chunk_size * 2; i += 2)
    {
        chunk_buffer[i] = color_bytes[0];
        chunk_buffer[i + 1] = color_bytes[1];
    }
    size_t total_pixels = ILI9341_DISPLAY_WIDTH * ILI9341_DISPLAY_HEIGHT;
    size_t pixels_sent = 0;
    while (pixels_sent < total_pixels)
    {
        size_t pixels_to_send = MIN(chunk_size, total_pixels - pixels_sent);
        int ret = ili9341_send_data(chunk_buffer, pixels_to_send * 2);
        if (ret < 0)
        {
            k_free(chunk_buffer);
            return ret;
        }
        pixels_sent += pixels_to_send;
    }
    k_free(chunk_buffer);
    return 0;
}

int ili9341_draw_color_bars(void)
{
    uint16_t colors[] = {WHITE_COLOR, RED_COLOR, GREEN_COLOR, BLUE_COLOR,
                         YELLOW_COLOR, MAGENTA_COLOR, CYAN_COLOR, BLACK_COLOR};
    int bar_height = ILI9341_DISPLAY_HEIGHT / 8;
    for (int i = 0; i < 8; i++)
    {
        int y_start = i * bar_height;
        int y_end = (i == 7) ? ILI9341_DISPLAY_HEIGHT - 1 : (i + 1) * bar_height - 1;
        ili9341_set_area(0, y_start, ILI9341_DISPLAY_WIDTH - 1, y_end);
        ili9341_send_cmd(ILI9341_RAMWR);
        uint8_t color_bytes[2] = {colors[i] >> 8, colors[i] & 0xFF};
        int pixels_in_bar = ILI9341_DISPLAY_WIDTH * (y_end - y_start + 1);
        for (int p = 0; p < pixels_in_bar; p++)
        {
            ili9341_send_data(color_bytes, 2);
        }
    }
    return 0;
}

int ili9341_draw_test_pattern(void)
{
    ili9341_set_area(0, 0, ILI9341_DISPLAY_WIDTH - 1, ILI9341_DISPLAY_HEIGHT - 1);
    ili9341_send_cmd(ILI9341_RAMWR);
    uint8_t white_bytes[2] = {WHITE_COLOR >> 8, WHITE_COLOR & 0xFF};
    uint8_t black_bytes[2] = {BLACK_COLOR >> 8, BLACK_COLOR & 0xFF};
    for (int y = 0; y < ILI9341_DISPLAY_HEIGHT; y++)
    {
        for (int x = 0; x < ILI9341_DISPLAY_WIDTH; x++)
        {
            bool checker = ((x / 20) + (y / 20)) % 2;
            uint8_t *color_bytes = checker ? white_bytes : black_bytes;
            ili9341_send_data(color_bytes, 2);
        }
    }
    return 0;
}

int ili9341_backlight_init(const struct device *gpio_dev, int pin)
{
    int ret = gpio_pin_configure(gpio_dev, pin, GPIO_OUTPUT_ACTIVE);
    if (ret < 0)
        return ret;
    gpio_pin_set(gpio_dev, pin, 1);
    LOG_DBG("Configuring backlight GPIO%d as output", pin);
    LOG_DBG("Backlight GPIO%d set HIGH", pin);
    return 0;
}

// Minimal 8x8 font (ASCII 32-127)
static const uint8_t font8x8_basic[96][8] = {
    // Space (32)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // '!' (33)
    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},
    // '"' (34)
    {0x36, 0x36, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00},
    // '#' (35)
    {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},
    // '$' (36)
    {0x0C, 0x1E, 0x33, 0x1E, 0x0C, 0x00, 0x1E, 0x00},
    // '%' (37)
    {0x63, 0x73, 0x1C, 0x08, 0x1C, 0x73, 0x63, 0x00},
    // '&' (38)
    {0x1C, 0x36, 0x36, 0x1C, 0x2A, 0x3E, 0x2A, 0x00},
    // ''' (39)
    {0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00},
    // '(' (40)
    {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00},
    // ')' (41)
    {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00},
    // '*' (42)
    {0x00, 0x24, 0x18, 0x3E, 0x18, 0x24, 0x00, 0x00},
    // '+' (43)
    {0x00, 0x00, 0x18, 0x18, 0x3E, 0x18, 0x18, 0x00},
    // ',' (44)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},
    // '-' (45)
    {0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00},
    // '.' (46)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},
    // '/' (47)
    {0x00, 0x00, 0x00, 0x00, 0x63, 0x32, 0x0C, 0x00},
    // '0' (48)
    {0x1C, 0x36, 0x36, 0x36, 0x36, 0x36, 0x1C, 0x00},
    // '1' (49)
    {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3E, 0x00},
    // '2' (50)
    {0x1C, 0x36, 0x06, 0x0C, 0x18, 0x30, 0x3E, 0x00},
    // '3' (51)
    {0x1C, 0x36, 0x06, 0x0C, 0x06, 0x36, 0x1C, 0x00},
    // '4' (52)
    {0x0C, 0x1C, 0x2C, 0x4C, 0x7E, 0x0C, 0x0C, 0x00},
    // '5' (53)
    {0x3E, 0x30, 0x30, 0x3C, 0x06, 0x36, 0x1C, 0x00},
    // '6' (54)
    {0x1C, 0x36, 0x30, 0x3C, 0x36, 0x36, 0x1C, 0x00},
    // '7' (55)
    {0x3E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00},
    // '8' (56)
    {0x1C, 0x36, 0x36, 0x1C, 0x36, 0x36, 0x1C, 0x00},
    // '9' (57)
    {0x1C, 0x36, 0x36, 0x1E, 0x06, 0x36, 0x1C, 0x00},
    // ':' (58)
    {0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00},
    // ';' (59)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},
    // '<' (60)
    {0x00, 0x00, 0x00, 0x18, 0x3C, 0x36, 0x00, 0x00},
    // '=' (61)
    {0x00, 0x00, 0x3E, 0x00, 0x3E, 0x00, 0x00, 0x00},
    // '>' (62)
    {0x00, 0x00, 0x00, 0x36, 0x3C, 0x18, 0x00, 0x00},
    // '?' (63)
    {0x1C, 0x36, 0x06, 0x0C, 0x00, 0x00, 0x00, 0x00},
    // '@' (64)
    {0x1C, 0x36, 0x36, 0x16, 0x1E, 0x00, 0x1C, 0x00},
    // 'A' (65)
    {0x1C, 0x36, 0x36, 0x1E, 0x36, 0x36, 0x36, 0x00},
    // 'B' (66)
    {0x3E, 0x36, 0x36, 0x3E, 0x36, 0x36, 0x3E, 0x00},
    // 'C' (67)
    {0x1C, 0x36, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00},
    // 'D' (68)
    {0x3E, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3E, 0x00},
    // 'E' (69)
    {0x3E, 0x30, 0x30, 0x3C, 0x30, 0x30, 0x3E, 0x00},
    // 'F' (70)
    {0x3E, 0x30, 0x30, 0x3C, 0x30, 0x30, 0x30, 0x00},
    // 'G' (71)
    {0x1C, 0x36, 0x30, 0x30, 0x36, 0x36, 0x1C, 0x00},
    // 'H' (72)
    {0x36, 0x36, 0x36, 0x3E, 0x36, 0x36, 0x36, 0x00},
    // 'I' (73)
    {0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1C, 0x00},
    // 'J' (74)
    {0x0E, 0x06, 0x06, 0x06, 0x06, 0x36, 0x1C, 0x00},
    // 'K' (75)
    {0x36, 0x36, 0x36, 0x3E, 0x36, 0x36, 0x36, 0x00},
    // 'L' (76)
    {0x30, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00},
    // 'M' (77)
    {0x36, 0x36, 0x36, 0x3E, 0x3E, 0x36, 0x36, 0x00},
    // 'N' (78)
    {0x36, 0x36, 0x36, 0x3E, 0x3E, 0x36, 0x36, 0x00},
    // 'O' (79)
    {0x1C, 0x36, 0x36, 0x36, 0x36, 0x36, 0x1C, 0x00},
    // 'P' (80)
    {0x3E, 0x36, 0x36, 0x3E, 0x30, 0x30, 0x30, 0x00},
    // 'Q' (81)
    {0x1C, 0x36, 0x36, 0x36, 0x36, 0x3E, 0x1C, 0x00},
    // 'R' (82)
    {0x3E, 0x36, 0x36, 0x3E, 0x36, 0x36, 0x36, 0x00},
    // 'S' (83)
    {0x1C, 0x36, 0x30, 0x1C, 0x06, 0x36, 0x1C, 0x00},
    // 'T' (84)
    {0x3E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00},
    // 'U' (85)
    {0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x1C, 0x00},
    // 'V' (86)
    {0x36, 0x36, 0x36, 0x36, 0x36, 0x1C, 0x1C, 0x00},
    // 'W' (87)
    {0x36, 0x36, 0x36, 0x3E, 0x3E, 0x3E, 0x36, 0x00},
    // 'X' (88)
    {0x36, 0x36, 0x1C, 0x1C, 0x1C, 0x36, 0x36, 0x00},
    // 'Y' (89)
    {0x36, 0x36, 0x1C, 0x1C, 0x1C, 0x18, 0x18, 0x00},
    // 'Z' (90)
    {0x3E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x3E, 0x00},
    // '[' (91)
    {0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},
    // '\' (92)
    {0x00, 0x00, 0x0C, 0x32, 0x63, 0x00, 0x00, 0x00},
    // ']' (93)
    {0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},
    // '^' (94)
    {0x00, 0x00, 0x00, 0x24, 0x18, 0x00, 0x00, 0x00},
    // '_' (95)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},
    // '`' (96)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x00},
    // 'a' (97)
    {0x00, 0x00, 0x1C, 0x36, 0x36, 0x36, 0x1E, 0x00},
    // 'b' (98)
    {0x30, 0x30, 0x30, 0x3C, 0x36, 0x36, 0x3C, 0x00},
    // 'c' (99)
    {0x00, 0x00, 0x1C, 0x36, 0x30, 0x30, 0x1C, 0x00},
    // 'd' (100)
    {0x06, 0x06, 0x06, 0x1E, 0x36, 0x36, 0x1E, 0x00},
    // 'e' (101)
    {0x00, 0x00, 0x1C, 0x36, 0x3C, 0x30, 0x1C, 0x00},
    // 'f' (102)
    {0x1C, 0x36, 0x06, 0x0E, 0x0C, 0x00, 0x0C, 0x00},
    // 'g' (103)
    {0x00, 0x00, 0x1C, 0x36, 0x36, 0x1E, 0x06, 0x3C},
    // 'h' (104)
    {0x36, 0x36, 0x36, 0x3E, 0x36, 0x36, 0x36, 0x00},
    // 'i' (105)
    {0x00, 0x00, 0x18, 0x00, 0x18, 0x18, 0x1C, 0x00},
    // 'j' (106)
    {0x00, 0x00, 0x06, 0x00, 0x06, 0x06, 0x36, 0x1C},
    // 'k' (107)
    {0x36, 0x36, 0x36, 0x3E, 0x36, 0x36, 0x36, 0x00},
    // 'l' (108)
    {0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1C, 0x00},
    // 'm' (109)
    {0x00, 0x00, 0x36, 0x3E, 0x3E, 0x36, 0x36, 0x00},
    // 'n' (110)
    {0x00, 0x00, 0x36, 0x3E, 0x3E, 0x36, 0x36, 0x00},
    // 'o' (111)
    {0x00, 0x00, 0x1C, 0x36, 0x36, 0x36, 0x1C, 0x00},
    // 'p' (112)
    {0x00, 0x00, 0x3C, 0x36, 0x36, 0x3C, 0x30, 0x30},
    // 'q' (113)
    {0x00, 0x00, 0x1E, 0x36, 0x36, 0x1E, 0x06, 0x06},
    // 'r' (114)
    {0x00, 0x00, 0x36, 0x3E, 0x30, 0x30, 0x30, 0x00},
    // 's' (115)
    {0x00, 0x00, 0x1C, 0x36, 0x1C, 0x06, 0x36, 0x1C},
    // 't' (116)
    {0x00, 0x00, 0x0C, 0x1E, 0x18, 0x18, 0x18, 0x00},
    // 'u' (117)
    {0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x1C, 0x00},
    // 'v' (118)
    {0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x1C, 0x00},
    // 'w' (119)
    {0x00, 0x00, 0x36, 0x3E, 0x3E, 0x3E, 0x36, 0x00},
    // 'x' (120)
    {0x00, 0x00, 0x36, 0x36, 0x1C, 0x1C, 0x36, 0x36},
    // 'y' (121)
    {0x00, 0x00, 0x36, 0x36, 0x1C, 0x1C, 0x18, 0x18},
    // 'z' (122)
    {0x00, 0x00, 0x3E, 0x06, 0x0C, 0x18, 0x3E, 0x00},
    // '{' (123)
    {0x1C, 0x36, 0x06, 0x0C, 0x0C, 0x06, 0x36, 0x1C},
    // '|' (124)
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00},
    // '}' (125)
    {0x36, 0x36, 0x0C, 0x06, 0x06, 0x0C, 0x36, 0x36},
    // '~' (126)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
    // (127)
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
};

// Draw a single pixel
void ili9341_draw_pixel(int x, int y, uint16_t color)
{
    // Set area to one pixel
    ili9341_set_area(x, y, x, y);
    ili9341_send_cmd(ILI9341_RAMWR);
    uint8_t color_bytes[2] = {color >> 8, color & 0xFF};
    ili9341_send_data(color_bytes, 2);
}

// Draw a single character at (x, y)
static void ili9341_draw_char(int x, int y, char c, uint16_t color)
{
    if (c < 32 || c > 127)
        return;
    const uint8_t *bitmap = font8x8_basic[c - 32];
    for (int row = 0; row < 8; row++)
    {
        for (int col = 0; col < 8; col++)
        {
            if (bitmap[row] & (1 << col))
            {
                ili9341_draw_pixel(x + col, y + row, color);
            }
        }
    }
}

// Draw a string at (x, y)
void ili9341_draw_text(int x, int y, const char *text, uint16_t color)
{
    int cursor_x = x;
    while (*text)
    {
        ili9341_draw_char(cursor_x, y, *text, color);
        cursor_x += 8; // Advance by character width
        text++;
    }
}

void ili9341_crt_screensaver(void)
{
    for (int frame = 0; frame < 100; frame++)
    {
        // Fill with black
        ili9341_fill_color(BLACK_COLOR);

        // Draw random colored horizontal lines (CRT scanlines)
        for (int y = 0; y < ILI9341_DISPLAY_HEIGHT; y += 2)
        {
            uint16_t color = (rand() % 2) ? CYAN_COLOR : MAGENTA_COLOR;
            for (int x = 0; x < ILI9341_DISPLAY_WIDTH; x++)
            {
                ili9341_draw_pixel(x, y, color);
            }
        }

        // Draw random glitch rectangles
        for (int i = 0; i < 5; i++)
        {
            int gx = rand() % (ILI9341_DISPLAY_WIDTH - 20);
            int gy = rand() % (ILI9341_DISPLAY_HEIGHT - 10);
            uint16_t gcolor = (rand() % 2) ? YELLOW_COLOR : WHITE_COLOR;
            for (int dx = 0; dx < 20; dx++)
            {
                for (int dy = 0; dy < 10; dy++)
                {
                    ili9341_draw_pixel(gx + dx, gy + dy, gcolor);
                }
            }
        }

        // Draw scrolling text
        int scroll_y = (frame * 4) % (ILI9341_DISPLAY_HEIGHT - 8);
        ili9341_draw_text(10, scroll_y, "Akira Console", CYAN_COLOR);

        k_sleep(K_MSEC(80));
    }
}